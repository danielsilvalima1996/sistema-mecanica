/**
 * @docsPrivate
 *
 * @description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
import * as ɵngcc0 from '@angular/core';
export declare class PoDateService {
    private readonly dateRegex;
    private readonly isoRegex;
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    convertIsoToDate(dateString: string, minDate: boolean, maxDate: boolean): Date;
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    convertDateToISO(date: Date): string;
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    formatYear(year: number): string;
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    getDateFromIso(isoDate: string): {
        year: number;
        month: number;
        day: number;
    };
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    getDateForDateRange(date: any, isMinDate: boolean): Date;
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    isDateRangeValid(dateA?: string, dateB?: string): boolean;
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    isValidIso(stringDate: string): boolean;
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    setYearFrom0To100(date: Date, year: number): void;
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    sortDate(leftSide: string | Date, rightSide: string | Date, ascending: boolean): number;
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    splitDate(date: Date): {
        year: number;
        month: number;
        day: number;
    };
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    validateDateRange(date: Date, minDate: Date, maxDate: Date): boolean;
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    private validateDate;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PoDateService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<PoDateService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbInBvLWRhdGUuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBkb2NzUHJpdmF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFNlcnZpw6dvIHJlc3BvbnPDoXZlbCBwb3IgZ2VyZW5jaWFyIG8gdHJhdGFtZW50byBkb3MgZm9ybWF0b3MgZGUgZGF0YSBlIGhvcmEuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFBvRGF0ZVNlcnZpY2Uge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0ZVJlZ2V4O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaXNvUmVnZXg7XG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvbnZlcnRlciBkYXRhcyBkbyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gIHBhcmEgbyBmb3JtYXRvIGBEYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlU3RyaW5nIERhdGEgbm8gZm9ybWF0byBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYC5cbiAgICAgKiBAcGFyYW0gbWluRGF0ZSBEZWZpbmlyIGB0cnVlYCBjYXNvIHNlamEgYG1pbkRhdGVgLlxuICAgICAqIEBwYXJhbSBtYXhEYXRlIERlZmluaXIgYHRydWVgIGNhc28gc2VqYSBgbWF4RGF0ZWAuXG4gICAgICovXG4gICAgY29udmVydElzb1RvRGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcsIG1pbkRhdGU6IGJvb2xlYW4sIG1heERhdGU6IGJvb2xlYW4pOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb252ZXJ0ZXIgZGF0YSBkbyBmb3JtYXRvIGBEYXRlYCBwYXJhIG8gZm9ybWF0byBgeXl5eS1tbS1kZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRhIG5vIGZvcm1hdG8gYERhdGVgLlxuICAgICAqL1xuICAgIGNvbnZlcnREYXRlVG9JU08oZGF0ZTogRGF0ZSk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgYWRpY2lvbmFyIHplcm9zIGEgZXNxdWVyZGEgZG8gYW5vcyBlbSBmb3JtYXRvIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyIEFubyBhIHNlciB2YWxpZGFkby5cbiAgICAgKi9cbiAgICBmb3JtYXRZZWFyKHllYXI6IG51bWJlcik6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgbyBkaWEsIG3DqnMgZSBhbm8gc2VwYXJhZG9zIGVtIGZvcm1hdG8gZGUgb2JqZXRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzb0RhdGUgQW5vIGVtIGZvcm1hdG8gc3RyaW5nLlxuICAgICAqL1xuICAgIGdldERhdGVGcm9tSXNvKGlzb0RhdGU6IHN0cmluZyk6IHtcbiAgICAgICAgeWVhcjogbnVtYmVyO1xuICAgICAgICBtb250aDogbnVtYmVyO1xuICAgICAgICBkYXk6IG51bWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciByZXRvcm5hciBhIGRhdGEgY29tIGEgaG9yYSBkZWZpbmlkYSBwYXJhIGAwMDowMDowMGAgY2FzbyBgaXNNaW5EYXRlYCBmb3IgaWd1YWwgYSBgdHJ1ZWAgb3UgYDIzOjU5OjU5YFxuICAgICAqIGNhc28gYGlzTWluZGF0ZWAgc2VqYSBpZ3VhbCBhIGBmYWxzZWAgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGUgRGF0YSBubyBmb3JtYXRvIGBEYXRlYCBvdSBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYC5cbiAgICAgKiBAcGFyYW0gaXNNaW5EYXRlIENhc28gYHRydWVgIGFwbGljYSBgMDA6MDA6MDBgLCBjYXNvIGBmYWxzZWAgYXBsaWNhIGAyMzo1OTo1OWAgYSBob3JhIGRhIGRhdGEgaW5mb3JtYWRhLlxuICAgICAqL1xuICAgIGdldERhdGVGb3JEYXRlUmFuZ2UoZGF0ZTogYW55LCBpc01pbkRhdGU6IGJvb2xlYW4pOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIFJldG9ybmEgYHRydWVgIGNhc28gbyBwZXLDrW9kbyBzZWphIHbDoWxpZG8sIHBhcmEgaXNzbyBhIHByaW1laXJhIGRhdGEgZGV2ZSBzZXIgbWFpb3IgcXVlIGEgc2VndW5kYSBkYXRhLlxuICAgICAqIEBwYXJhbSBkYXRlQSBwcmltZWlyYSBkYXRhXG4gICAgICogQHBhcmFtIGRhdGVCIHNlZ3VuZGEgZGF0YVxuICAgICAqL1xuICAgIGlzRGF0ZVJhbmdlVmFsaWQoZGF0ZUE/OiBzdHJpbmcsIGRhdGVCPzogc3RyaW5nKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgdmFsaWRhciBzZSB1bWEgZGF0YSBlc3TDoSBubyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gIG91IGB5eXl5LW1tLWRkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmdEYXRlIERhdGEuXG4gICAgICovXG4gICAgaXNWYWxpZElzbyhzdHJpbmdEYXRlOiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb3JyaWdpciBhIGRhdGEgY2FzbyBhIG1lc21hIGVzdGVqYSBlbnRyZSBvcyBhbm9zIDAgZSA5OS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIERhdGEuXG4gICAgICogQHBhcmFtIHllYXIgLlxuICAgICAqL1xuICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGU6IERhdGUsIHllYXI6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIG9yZGVuYXIgZHVhcyBkYXRhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZWZ0U2lkZSBQcmltZWlyYSBkYXRhIGEgc2VyIGNvbXBhcmFkYS5cbiAgICAgKiBAcGFyYW0gcmlnaHRTaWRlIFNlZ3VuZGEgZGF0YSBhIHNlciBjb21wYXJhZGEuXG4gICAgICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gY3Jlc2NlbnRlIG91IGRlY3Jlc2NlbnRlLlxuICAgICAqL1xuICAgIHNvcnREYXRlKGxlZnRTaWRlOiBzdHJpbmcgfCBEYXRlLCByaWdodFNpZGU6IHN0cmluZyB8IERhdGUsIGFzY2VuZGluZzogYm9vbGVhbik6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgbyBkaWEgLCBtw6pzIGUgYW5vIGRlIHVtYSBkYXRhIGluZm9ybWFkYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIFZhbG9yIGRhIGRhdGEuXG4gICAgICovXG4gICAgc3BsaXREYXRlKGRhdGU6IERhdGUpOiB7XG4gICAgICAgIHllYXI6IG51bWJlcjtcbiAgICAgICAgbW9udGg6IG51bWJlcjtcbiAgICAgICAgZGF5OiBudW1iZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgdmFsaWRhciBzZSB1bWEgZGF0YSBlc3TDoSBlbnRyZSBhIGBtaW5EYXRlYCBlIGBtYXhEYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIERhdGEgYSBzZXIgdmFsaWRhZGEuXG4gICAgICogQHBhcmFtIG1pbkRhdGUgRGF0YSBpbmljaWFsLlxuICAgICAqIEBwYXJhbSBtYXhEYXRlIERhdGEgZmluYWwuXG4gICAgICovXG4gICAgdmFsaWRhdGVEYXRlUmFuZ2UoZGF0ZTogRGF0ZSwgbWluRGF0ZTogRGF0ZSwgbWF4RGF0ZTogRGF0ZSk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgYSBkYXRhIGZvaSBpbmZvcm1hZGEgbm9zIHBhZHLDtWVzICd5eXl5LW1tLWRkJywgJ3l5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbScgb3VcbiAgICAgKiAnRGF0ZScgcGFkcsOjbyBkbyBqYXZhc2NyaXB0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGUgRGF0YSBxdWUgc2Vyw6EgdmFsaWRhZGEuXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZURhdGU7XG59XG4iXX0=
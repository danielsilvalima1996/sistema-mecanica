import { AbstractControl, ControlValueAccessor, ValidationErrors, Validator } from '@angular/forms';
import { EventEmitter } from '@angular/core';
import { PoDatepickerRange } from './interfaces/po-datepicker-range.interface';
import { PoDatepickerRangeLiterals } from './interfaces/po-datepicker-range-literals.interface';
import { PoDateService } from './../../../services/po-date/po-date.service';
import * as ɵngcc0 from '@angular/core';
export declare const poDatepickerRangeLiteralsDefault: {
    en: PoDatepickerRangeLiterals;
    es: PoDatepickerRangeLiterals;
    pt: PoDatepickerRangeLiterals;
    ru: PoDatepickerRangeLiterals;
};
/**
 * @description
 *
 * O `po-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `po-datepicker-range` trabalha com um objeto que implementa a interface
 * `PoDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `p-start-date` e `p-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 */
export declare abstract class PoDatepickerRangeBaseComponent implements ControlValueAccessor, Validator {
    protected poDateService: PoDateService;
    errorMessage: string;
    private _clean?;
    private _disabled?;
    private _endDate?;
    private _literals?;
    private _noAutocomplete?;
    private _readonly;
    private _required?;
    private _startDate?;
    private onChangeModel;
    private validatorChange;
    protected dateRange: PoDatepickerRange;
    protected format: any;
    protected isDateRangeInputFormatValid: boolean;
    protected isStartDateRangeInputValid: boolean;
    protected onTouchedModel: any;
    get isDateRangeInputValid(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Aplica foco no elemento ao ser iniciado.
     *
     * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
     *
     * @default `false`
     */
    autoFocus: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Habilita ação para limpar o campo.
     *
     * @default `false`
     */
    set clean(clean: boolean);
    get clean(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Desabilita o campo.
     *
     * @default `false`
     */
    set disabled(value: boolean);
    get disabled(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data final.
     */
    set endDate(date: string | Date);
    get endDate(): string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Texto de apoio do campo.
     */
    help?: string;
    /**
     * @optional
     *
     * @description
     *
     * Rótulo do campo.
     */
    label?: string;
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as literais usadas no `po-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <po-datepicker-range
     *   [p-literals]="customLiterals">
     * </po-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     */
    set literals(value: PoDatepickerRangeLiterals);
    get literals(): PoDatepickerRangeLiterals;
    /**
     * @optional
     *
     * @description
     *
     * Define a propriedade nativa `autocomplete` do campo como `off`.
     *
     * @default `false`
     */
    set noAutocomplete(value: boolean);
    get noAutocomplete(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `p-required`;
     * - Não possuir `p-help` e/ou `p-label`.
     *
     * @default `false`
     */
    optional: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será somente leitura.
     *
     * @default `false`
     */
    set readonly(value: boolean);
    get readonly(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será obrigatório.
     *
     * @default `false`
     */
    set required(required: boolean);
    get required(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data inicial.
     */
    set startDate(date: string | Date);
    get startDate(): string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Evento disparado ao alterar valor do campo.
     */
    onChange?: EventEmitter<any>;
    constructor(poDateService: PoDateService);
    protected abstract resetDateRangeInputValidation(): void;
    protected abstract updateScreenByModel(dateRange: PoDatepickerRange): any;
    registerOnChange(func: any): void;
    registerOnTouched(func: any): void;
    registerOnValidatorChange?(fn: () => void): void;
    validate(control: AbstractControl): ValidationErrors;
    writeValue(dateRange: PoDatepickerRange): void;
    protected dateFormatFailed(value: string): boolean;
    protected updateModel(value: any): void;
    protected validateModel(value: any): void;
    private convertPatternDateFormat;
    private dateRangeFailed;
    private dateRangeFormatFailed;
    private dateRangeObjectFailed;
    private isDateRangeObject;
    private requiredDateRangeFailed;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PoDatepickerRangeBaseComponent, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PoDatepickerRangeBaseComponent, never, never, { "autoFocus": "p-auto-focus"; "clean": "p-clean"; "disabled": "p-disabled"; "endDate": "p-end-date"; "literals": "p-literals"; "noAutocomplete": "p-no-autocomplete"; "readonly": "p-readonly"; "required": "p-required"; "startDate": "p-start-date"; "help": "p-help"; "label": "p-label"; "optional": "p-optional"; }, { "onChange": "p-change"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZXBpY2tlci1yYW5nZS1iYXNlLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJwby1kYXRlcGlja2VyLXJhbmdlLWJhc2UuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUG9EYXRlcGlja2VyUmFuZ2UgfSBmcm9tICcuL2ludGVyZmFjZXMvcG8tZGF0ZXBpY2tlci1yYW5nZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1kYXRlcGlja2VyLXJhbmdlLWxpdGVyYWxzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0RhdGVTZXJ2aWNlIH0gZnJvbSAnLi8uLi8uLi8uLi9zZXJ2aWNlcy9wby1kYXRlL3BvLWRhdGUuc2VydmljZSc7XG5leHBvcnQgZGVjbGFyZSBjb25zdCBwb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdDoge1xuICAgIGVuOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xuICAgIGVzOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xuICAgIHB0OiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xuICAgIHJ1OiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTyBgcG8tZGF0ZXBpY2tlci1yYW5nZWAgw6kgdW0gY29tcG9uZW50ZSBwYXJhIHNlbGXDp8OjbyBkZSB1bSBwZXLDrW9kbyBlbnRyZSBkdWFzIGRhdGFzLCBvbmRlIMOpIHBvc3PDrXZlbCBpbmZvcm1hciBhcGVuYXNcbiAqIGEgZGF0YSBpbmljaWFsIG91IGEgZGF0YSBmaW5hbC5cbiAqXG4gKiBPIGNvbXBvbmVudGUgYFsobmdNb2RlbCldYCBkbyBgcG8tZGF0ZXBpY2tlci1yYW5nZWAgdHJhYmFsaGEgY29tIHVtIG9iamV0byBxdWUgaW1wbGVtZW50YSBhIGludGVyZmFjZVxuICogYFBvRGF0ZXBpY2tlclJhbmdlYCwgY29udGVuZG8gYXMgc2VndWludGVzIHByb3ByaWVkYWRlczpcbiAqIGBgYFxuICogeyBcInN0YXJ0XCI6ICcyMDE3LTExLTI4JywgXCJlbmRcIjogJzIwMTctMTEtMzAnIH1cbiAqIGBgYFxuICpcbiAqIDxhIGlkPVwiYWNjZXB0ZWQtZm9ybWF0c1wiPjwvYT5cbiAqIEVzdGUgY29tcG9uZW50ZSBwb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XG4gKlxuICogLSAqKkRhdGEgZSBob3JhIGNvbWJpbmFkb3MgKEU4NjAxRFp3KTogeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tKipcbiAqIGBgYFxuICogJzIwMTctMTEtMjhUMDA6MDA6MDAtMDI6MDAnO1xuICogYGBgXG4gKlxuICogLSAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKlxuICogYGBgXG4gKiAnMjAxNy0xMS0yOCc7XG4gKiBgYGBcbiAqXG4gKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxuICogYGBgXG4gKiBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpO1xuICogYGBgXG4gKlxuICogPiBPIGNvbXBvbmVudGUgcmVzcGVpdGFyw6EgbyBmb3JtYXRvIHBhc3NhZG8gcGFyYSBvICptb2RlbCogdmlhIGNvZGlmaWNhw6fDo28uIFBvcsOpbSwgY2FzbyBzZWphIGZlaXRhIGFsdGVyYcOnw6NvIGVtIGFsZ3VtXG4gKiBkb3MgdmFsb3JlcyBkZSBkYXRhIGVtIHRlbGEsIG8gY29tcG9uZW50ZSBhdHJpYnVpcsOhIG8gZm9ybWF0byAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKiBhbyBtb2RlbC5cbiAqXG4gKiBJbXBvcnRhbnRlOlxuICpcbiAqIC0gUXVhbmRvIHByZWVuY2hpZGFzIGEgZGF0YSBpbmljaWFsIGUgZmluYWwsIGEgZGF0YSBpbmljaWFsIGRldmUgc2VyIHNlbXByZSBtZW5vciBvdSBpZ3VhbCBhIGRhdGEgZmluYWw7XG4gKiAtIEFvIHBhc3NhciB1bWEgZGF0YSBpbnbDoWxpZGEgdmlhIGNvZGlmaWNhw6fDo28sIG8gdmFsb3Igc2Vyw6EgbWFudGlkbyBubyAqbW9kZWwqIGUgbyBgaW5wdXRgIGRhIHRlbGEgYXBhcmVjZXLDoSB2YXppbztcbiAqIC0gUGVybWl0ZSB0cmFiYWxoYXIgY29tIGFzIGR1YXMgZGF0YXMgc2VwYXJhZGFtZW50ZSBhdHJhdsOpcyBkYXMgcHJvcHJpZWRhZGVzIGBwLXN0YXJ0LWRhdGVgIGUgYHAtZW5kLWRhdGVgIG5vIGx1Z2FyIGRvXG4gKiBgWyhuZ01vZGVsKV1gLCBubyBlbnRhbnRvIHNlbSBhIHZhbGlkYcOnw6NvIGRvIGZvcm11bMOhcmlvO1xuICogLSBQYXJhIGEgdmFsaWRhw6fDo28gZG8gZm9ybXVsw6FyaW8sIHV0aWxpemUgbyBgWyhuZ01vZGVsKV1gLlxuICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBQb0RhdGVwaWNrZXJSYW5nZUJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcbiAgICBwcm90ZWN0ZWQgcG9EYXRlU2VydmljZTogUG9EYXRlU2VydmljZTtcbiAgICBlcnJvck1lc3NhZ2U6IHN0cmluZztcbiAgICBwcml2YXRlIF9jbGVhbj87XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ/O1xuICAgIHByaXZhdGUgX2VuZERhdGU/O1xuICAgIHByaXZhdGUgX2xpdGVyYWxzPztcbiAgICBwcml2YXRlIF9ub0F1dG9jb21wbGV0ZT87XG4gICAgcHJpdmF0ZSBfcmVhZG9ubHk7XG4gICAgcHJpdmF0ZSBfcmVxdWlyZWQ/O1xuICAgIHByaXZhdGUgX3N0YXJ0RGF0ZT87XG4gICAgcHJpdmF0ZSBvbkNoYW5nZU1vZGVsO1xuICAgIHByaXZhdGUgdmFsaWRhdG9yQ2hhbmdlO1xuICAgIHByb3RlY3RlZCBkYXRlUmFuZ2U6IFBvRGF0ZXBpY2tlclJhbmdlO1xuICAgIHByb3RlY3RlZCBmb3JtYXQ6IGFueTtcbiAgICBwcm90ZWN0ZWQgaXNEYXRlUmFuZ2VJbnB1dEZvcm1hdFZhbGlkOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBpc1N0YXJ0RGF0ZVJhbmdlSW5wdXRWYWxpZDogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgb25Ub3VjaGVkTW9kZWw6IGFueTtcbiAgICBnZXQgaXNEYXRlUmFuZ2VJbnB1dFZhbGlkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFwbGljYSBmb2NvIG5vIGVsZW1lbnRvIGFvIHNlciBpbmljaWFkby5cbiAgICAgKlxuICAgICAqID4gQ2FzbyBtYWlzIGRlIHVtIGVsZW1lbnRvIHNlamEgY29uZmlndXJhZG8gY29tIGVzc2EgcHJvcHJpZWRhZGUsIGFwZW5hcyBvIMO6bHRpbW8gZWxlbWVudG8gZGVjbGFyYWRvIGNvbSBlbGEgdGVyw6EgbyBmb2NvLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgICAqL1xuICAgIGF1dG9Gb2N1czogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSGFiaWxpdGEgYcOnw6NvIHBhcmEgbGltcGFyIG8gY2FtcG8uXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICovXG4gICAgc2V0IGNsZWFuKGNsZWFuOiBib29sZWFuKTtcbiAgICBnZXQgY2xlYW4oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGVzYWJpbGl0YSBvIGNhbXBvLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIERhdGEgZmluYWwuXG4gICAgICovXG4gICAgc2V0IGVuZERhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSk7XG4gICAgZ2V0IGVuZERhdGUoKTogc3RyaW5nIHwgRGF0ZTtcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVGV4dG8gZGUgYXBvaW8gZG8gY2FtcG8uXG4gICAgICovXG4gICAgaGVscD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUsOzdHVsbyBkbyBjYW1wby5cbiAgICAgKi9cbiAgICBsYWJlbD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogT2JqZXRvIGNvbSBhcyBsaXRlcmFpcyB1c2FkYXMgbm8gYHBvLWRhdGVwaWNrZXItcmFuZ2VgLlxuICAgICAqXG4gICAgICogRXhpc3RlbSBkdWFzIG1hbmVpcmFzIGRlIGN1c3RvbWl6YXIgbyBjb21wb25lbnRlLCBwYXNzYW5kbyB1bSBvYmpldG8gY29tIHRvZGFzIGFzIGxpdGVyYWlzIGRpc3BvbsOtdmVpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICBjb25zdCBjdXN0b21MaXRlcmFsczogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyA9IHtcbiAgICAgKiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbmNvbnNpc3RlbnQgZm9ybWF0JyxcbiAgICAgKiAgICBzdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU6ICdFbmQgZGF0ZSBsZXNzIHRoYW4gc3RhcnQgZGF0ZSdcbiAgICAgKiAgfTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE91IHBhc3NhbmRvIGFwZW5hcyBhcyBsaXRlcmFpcyBxdWUgZGVzZWphIGN1c3RvbWl6YXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgY29uc3QgY3VzdG9tTGl0ZXJhbHM6IFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHMgPSB7XG4gICAgICogICAgaW52YWxpZEZvcm1hdDogJ0RhdGUgaW4gaW5jb25zaXN0ZW50IGZvcm1hdCdcbiAgICAgKiAgfTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEUgcGFyYSBjYXJyZWdhciBhcyBsaXRlcmFpcyBjdXN0b21pemFkYXMsIGJhc3RhIGFwZW5hcyBwYXNzYXIgbyBvYmpldG8gcGFyYSBvIGNvbXBvbmVudGUuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8cG8tZGF0ZXBpY2tlci1yYW5nZVxuICAgICAqICAgW3AtbGl0ZXJhbHNdPVwiY3VzdG9tTGl0ZXJhbHNcIj5cbiAgICAgKiA8L3BvLWRhdGVwaWNrZXItcmFuZ2U+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiA+IE8gb2JqZXRvIHBhZHLDo28gZGUgbGl0ZXJhaXMgc2Vyw6EgdHJhZHV6aWRvIGRlIGFjb3JkbyBjb20gbyBpZGlvbWEgZG8gYnJvd3NlciAocHQsIGVuLCBlcykuXG4gICAgICovXG4gICAgc2V0IGxpdGVyYWxzKHZhbHVlOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzKTtcbiAgICBnZXQgbGl0ZXJhbHMoKTogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscztcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGVmaW5lIGEgcHJvcHJpZWRhZGUgbmF0aXZhIGBhdXRvY29tcGxldGVgIGRvIGNhbXBvIGNvbW8gYG9mZmAuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICovXG4gICAgc2V0IG5vQXV0b2NvbXBsZXRlKHZhbHVlOiBib29sZWFuKTtcbiAgICBnZXQgbm9BdXRvY29tcGxldGUoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGVmaW5lIHNlIGEgaW5kaWNhw6fDo28gZGUgY2FtcG8gb3BjaW9uYWwgc2Vyw6EgZXhpYmlkYS5cbiAgICAgKlxuICAgICAqID4gTsOjbyBzZXLDoSBleGliaWRhIGEgaW5kaWNhw6fDo28gc2U6XG4gICAgICogLSBPIGNhbXBvIGNvbnRlciBgcC1yZXF1aXJlZGA7XG4gICAgICogLSBOw6NvIHBvc3N1aXIgYHAtaGVscGAgZS9vdSBgcC1sYWJlbGAuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICovXG4gICAgb3B0aW9uYWw6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEluZGljYSBxdWUgbyBjYW1wbyBzZXLDoSBzb21lbnRlIGxlaXR1cmEuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICovXG4gICAgc2V0IHJlYWRvbmx5KHZhbHVlOiBib29sZWFuKTtcbiAgICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIG9icmlnYXTDs3Jpby5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICAgKi9cbiAgICBzZXQgcmVxdWlyZWQocmVxdWlyZWQ6IGJvb2xlYW4pO1xuICAgIGdldCByZXF1aXJlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBEYXRhIGluaWNpYWwuXG4gICAgICovXG4gICAgc2V0IHN0YXJ0RGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKTtcbiAgICBnZXQgc3RhcnREYXRlKCk6IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEV2ZW50byBkaXNwYXJhZG8gYW8gYWx0ZXJhciB2YWxvciBkbyBjYW1wby5cbiAgICAgKi9cbiAgICBvbkNoYW5nZT86IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIGNvbnN0cnVjdG9yKHBvRGF0ZVNlcnZpY2U6IFBvRGF0ZVNlcnZpY2UpO1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZXNldERhdGVSYW5nZUlucHV0VmFsaWRhdGlvbigpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCB1cGRhdGVTY3JlZW5CeU1vZGVsKGRhdGVSYW5nZTogUG9EYXRlcGlja2VyUmFuZ2UpOiBhbnk7XG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmdW5jOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmM6IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZT8oZm46ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnM7XG4gICAgd3JpdGVWYWx1ZShkYXRlUmFuZ2U6IFBvRGF0ZXBpY2tlclJhbmdlKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZGF0ZUZvcm1hdEZhaWxlZCh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgdXBkYXRlTW9kZWwodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlTW9kZWwodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBjb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQ7XG4gICAgcHJpdmF0ZSBkYXRlUmFuZ2VGYWlsZWQ7XG4gICAgcHJpdmF0ZSBkYXRlUmFuZ2VGb3JtYXRGYWlsZWQ7XG4gICAgcHJpdmF0ZSBkYXRlUmFuZ2VPYmplY3RGYWlsZWQ7XG4gICAgcHJpdmF0ZSBpc0RhdGVSYW5nZU9iamVjdDtcbiAgICBwcml2YXRlIHJlcXVpcmVkRGF0ZVJhbmdlRmFpbGVkO1xufVxuIl19